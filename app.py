# -*- coding: utf-8 -*-

"""
Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W22q2RxokTPtLFgdq3SCmwdTbgqylMkp
"""

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Conv1D, MaxPooling1D, LSTM, Dense, Dropout
from tensorflow.keras.optimizers import Adam

st.set_page_config(page_title="üíß Water Usage Predictor (CNN + LSTM)", layout="wide")
st.title("üíß AI-based Smart Water Usage Prediction")
st.write("This app predicts daily household water usage using a **CNN + LSTM Hybrid Deep Learning Model**.")

dataset = pd.read_csv("dataset.csv")
dataset
st.subheader("üìä Sample Data")
st.dataframe(dataset.head())

scaler = MinMaxScaler()
scaled = scaler.fit_transform(dataset)

def create_sequences(data, seq_length=7):
    X, y = [], []
    for i in range(len(data) - seq_length):
        X.append(data[i:i+seq_length, :-1])  # past 7 days features
        y.append(data[i+seq_length, -1])     # next day target
    return np.array(X), np.array(y)

seq_length = 7
X, y = create_sequences(scaled, seq_length)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

@st.cache_resource
def build_model():
    model = Sequential([
        Conv1D(64, kernel_size=2, activation='relu', input_shape=(seq_length, X_train.shape[2])),
        MaxPooling1D(pool_size=2),
        Dropout(0.2),
        LSTM(64, activation='tanh'),
        Dropout(0.3),
        Dense(64, activation='relu'),
        Dense(1, activation='linear')
    ])
    model.compile(optimizer=Adam(learning_rate=0.001), loss='mse', metrics=['mae'])
    return model

model = build_model()

st.header("üöÄ Model Training")
epochs = st.slider("Training Epochs", 10, 200, 50)
if st.button("Train Model"):
    with st.spinner("Training model... Please wait ‚è≥"):
        history = model.fit(X_train, y_train, epochs=epochs, batch_size=16,
                            validation_data=(X_test, y_test), verbose=0)
    st.success("üéâ Model training complete!")

if st.button("Train Model"):
    with st.spinner("Training..."):
        history = model.fit(
            X_train, y_train,
            epochs=50,
            batch_size=16,
            validation_data=(X_test, y_test),
            verbose=0
        )

    st.success("Training Complete!")

    # SHOW HISTORY KEYS
    st.write("History keys:", history.history.keys())

    # LOSS PLOTS
    loss = history.history.get("loss", [])
    val_loss = history.history.get("val_loss", [])

    if loss and val_loss:
        fig1, ax1 = plt.subplots()
        ax1.plot(loss, label="Training Loss")
        ax1.plot(val_loss, label="Validation Loss")
        ax1.legend()
        st.pyplot(fig1)
    else:
        st.error("‚ùå No loss data found.")

# ----- Prediction on Test -----
y_pred_scaled = model.predict(X_test)

pred_full = np.zeros((len(y_pred_scaled), scaled.shape[1]))
true_full = np.zeros((len(y_test), scaled.shape[1]))

pred_full[:, -1] = y_pred_scaled.flatten()
true_full[:, -1] = y_test.flatten()

y_pred = scaler.inverse_transform(pred_full)[:, -1]
y_true = scaler.inverse_transform(true_full)[:, -1]


# ----- Plot Actual vs Predicted -----
st.subheader("üîé Actual vs Predicted Water Usage")
fig2, ax2 = plt.subplots(figsize=(10, 4))
ax2.plot(y_true[:100], label="Actual Usage", linewidth=2)
ax2.plot(y_pred[:100], label="Predicted Usage", linestyle='--', linewidth=2)
ax2.set_xlabel("Sample Index")
ax2.set_ylabel("Water Usage (Liters)")
ax2.grid(True)
ax2.legend()
st.pyplot(fig2)


# ----- Predict next day -----
n_features = scaled.shape[1] - 1

last_7 = scaled[-seq_length:, :-1].reshape(1, seq_length, n_features)
next_scaled = model.predict(last_7)

next_full = np.zeros((1, scaled.shape[1]))
next_full[0, -1] = next_scaled[0][0]

predicted_usage = scaler.inverse_transform(next_full)[0, -1]

st.success(f"üíß Predicted next-day water usage: **{predicted_usage:.2f} liters**")
